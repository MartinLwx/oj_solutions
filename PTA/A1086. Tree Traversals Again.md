#### é¢˜æ„

é¢˜ç›®ç»™å‡ºæ ˆçš„æ“ä½œåºåˆ—å®ç°ï¼Œè¦æ±‚ç»™å‡ºè¿™ä¸ªæ ‘çš„ååºéå†ã€‚

ä¸€å¼€å§‹æ²¡çœ‹æ‡‚é¢˜ç›®ä¸çŸ¥é“è¿™ä¸ªåºåˆ—æ˜¯ä»€ä¹ˆæ„æ€ğŸ˜ ï¼Œå°±æŠŠå‡ºæ ˆåºåˆ—å†™å‡ºæ¥çœ‹çœ‹å‘ç°æ˜¯ä¸­åºåºåˆ—ï¼Œè€Œå…¥æ ˆåºåˆ—æ˜¯`Push`çš„é¡ºåº

#### æ€è·¯

- ç”±æ­¤æˆ‘ä»¬å¯ä»¥çŸ¥é“â€”â€”è¿™é¢˜è€ƒçš„å°±æ˜¯å¤„ç†å­—ç¬¦ä¸²åºåˆ—å¾—åˆ°**å…ˆåºå’Œä¸­åºçš„éå†**ï¼Œç„¶åè¦æ±‚ç»™å‡ºè¿™é¢—äºŒå‰æ ‘çš„ååºéå†

- 1âƒ£ï¸æ€è·¯ä¸€

  - æ˜¯æœ€è¿‘å¤ä¹ ã€Šç®—æ³•ç¬”è®°ã€‹é‡Œé¢çš„ä¼ ç»Ÿå›ºå®šå†™æ³•ï¼Œå…ˆæŠŠäºŒå‰æ ‘æ„å»ºèµ·æ¥ï¼Œç„¶åå†å»å¤„ç†ï¼Œä¹Ÿæ˜¯é©¾è½»å°±ç†Ÿäº†

- 2âƒ£ï¸æ€è·¯äºŒ

  - ç¬¬äºŒä¸ªæ€è·¯æ˜¯å¾—ç›Šäºä¸Šä¸€æ¬¡åšçš„[A1020. Traversals](https://www.cnblogs.com/MartinLwx/p/13748989.html)ã€‚åæ¥å»çœ‹äº†æŸ³ç¥çš„åšå®¢ï¼Œå‘ç°äº†å¯ä»¥ä¸ç”¨å»ºæ ‘ç›´æ¥é€’å½’è¾“å‡ºå·¦å³å­æ ‘çš„æ–¹æ³•ã€‚æˆ‘çš„ç†è§£å°±æ˜¯â€”â€”æ¯æ¬¡æ ¹æ®ä¸­åºåºåˆ—å’Œå‰åºåºåˆ—å®šä½å‡ºå·¦å³å­æ ‘ï¼ˆ**åœ¨ä¸­åºåºåˆ—ä¸­æ‰¾åˆ°æ ¹çš„ä½ç½®**ï¼‰ï¼Œå»å¯¹åº”çš„å·¦å³å­æ ‘é‡Œé¢é€’å½’è¾“å‡ºã€‚æˆ‘æ˜¯æŒ‰ç…§å’Œç»å…¸çš„æ ‘çš„ååºéå†çš„é€’å½’å†™æ³•æ¥ç†è§£è¿™ä¸ªä»£ç çš„=_=

    ```c++
    void pre(int root, int start, int end)
    {
        if(start > end)
            return;
        int pos = start;
        while(pos < end && in_order[pos] != pre_order[root])   pos++;   //posæŒ‡å‘æ ¹
        int numLeft = pos - start;
        pre(root + 1, start, pos - 1);
        pre(root + numLeft + 1, pos + 1, end);
        ans.emplace_back(pre_order[root]);
    }
    
    void travel(Node* root)
    {
        if(root)
        {
            travel(root->left);
            travel(root->right);
            ans.emplace_back(root->val);
        }
    }
    ```

#### ä»£ç ï¼ˆä¼ ç»Ÿåšæ³•ï¼šå»ºç«‹äºŒå‰æ ‘åé€’å½’ç”¨ååºéå†ï¼‰

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <stack>
using namespace std;
int n;
vector<int> pre_order;
vector<int> in_order;
stack<int> s;      //æ¨¡æ‹Ÿé¢˜ç›®ä¸­çš„æ ˆ
vector<int> ans;   //å­˜æ”¾ç­”æ¡ˆ
struct Node{
    int val;
    Node* left;
    Node* right;
};
Node* Create(int preL, int preR, int inL, int inR)
{
    if(preL > preR)
        return NULL;
    Node* root = new Node;
    root->val = pre_order[preL];
    int pos;
    for(pos=inL;pos<=inR;pos++)   //ä¸­åºåºåˆ—ä¸­æ‰¾æ ¹
    {
        if(in_order[pos] == root->val)
            break;
    }
    int numLeft = pos - inL;
    //åˆ’åˆ†å‡ºå·¦å³å­æ ‘é€’å½’å»ºæ ‘
    root->left = Create(preL + 1, preL + numLeft, inL, pos - 1);   
    root->right = Create(preL + numLeft + 1, preR, pos + 1, inR);
    return root;
}//å»ºç«‹äºŒå‰æ ‘çš„è¿‡ç¨‹
void travel(Node* root)
{
    if(root)
    {
        travel(root->left);
        travel(root->right);
        ans.emplace_back(root->val);
    }
}//ä¼ ç»Ÿçš„é€’å½’ååºéå†
int main()
{
    cin >> n;
    string str;
    int node;
    for(int i=0;i<2*n;i++)
    {
        cin >> str;
        if(str == "Push")
        {
            cin >> node;
            s.push(node);
            pre_order.emplace_back(node);
        }else if(str == "Pop"){
            in_order.emplace_back(s.top());
            s.pop();
        }
    }
    Node* root = Create(0, pre_order.size() - 1, 0, in_order.size() - 1);
    travel(root);
    for(int i=0;i<ans.size();i++)
        i == ans.size() - 1 ? cout << ans[i] : cout << ans[i] << " ";
    return 0;
}
```

#### ä»£ç ï¼ˆç›´æ¥åœ¨é€’å½’çš„æ—¶å€™å¾—åˆ°æƒ³è¦çš„åºåˆ—ï¼‰

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <stack>
using namespace std;
int n;
vector<int> pre_order;
vector<int> in_order;
stack<int> s;
vector<int> ans;
void pre(int root, int start, int end)
{
    if(start > end)
        return;
    int pos = start;
    while(pos < end && in_order[pos] != pre_order[root])   pos++;
    int numLeft = pos - start;
    pre(root + 1, start, pos - 1);
    pre(root + numLeft + 1, pos + 1, end);
    ans.emplace_back(pre_order[root]);
    
}
int main()
{
    cin >> n;
    string str;
    int node;
    for(int i=0;i<2*n;i++)
    {
        cin >> str;
        if(str == "Push")
        {
            cin >> node;
            s.push(node);
            pre_order.emplace_back(node);
        }else if(str == "Pop"){
            in_order.emplace_back(s.top());
            s.pop();
        }
    }
    pre(0, 0, pre_order.size() - 1);
    for(int i=0;i<ans.size();i++)
        i == ans.size() - 1 ? cout << ans[i] : cout << ans[i] << " ";
    return 0;
}
```

