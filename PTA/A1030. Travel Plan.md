#### é¢˜æ„

æ‰¾åˆ°èµ·ç‚¹å’ŒåŸç‚¹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œå¦‚æœæœ€çŸ­è·¯å¾„ï¼ˆç”¨distanceåº¦é‡ï¼‰ä¸å”¯ä¸€ï¼Œé‚£ä¹ˆæ‰¾å‡ºcostæœ€å°‘çš„é‚£æ¡ï¼Œé¢˜ç›®ä¿è¯æ­¤ç§æƒ…å†µä¸‹æ˜¯å”¯ä¸€çš„

#### æ€è·¯

- å¤ä¹ äº†ä¸€éç®—æ³•ç¬”è®°é‡Œçš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œç»ˆäºèƒ½å®Œæ•´åœ°å†™å‡ºDijkstraç®—æ³•æ‰¾æœ€çŸ­è·¯å¾„é—®é¢˜äº†ã€‚
- è¿™ä¸€é¢˜ä»…ä»…æ˜¯åœ¨Dijkstraç®—æ³•çš„åŸºç¡€ä¸Šå¾—åˆ°çš„æ‰€æœ‰æœ€çŸ­è·¯å¾„ä¸­ï¼Œå†åˆ©ç”¨ç¬¬äºŒ ä¸ªåº¦é‡`cost`æ¥è¿›è¡Œæœ€ä¼˜è·¯å¾„çš„é€‰æ‹©ï¼Œæ–¹æ³•æ˜¯ç”¨`dfs`ï¼Œä¹Ÿå°±æ˜¯åˆ©ç”¨**å›æº¯ç®—æ³•**éå†æ‰€æœ‰çš„è·¯å¾„ï¼Œåœ¨è·¯å¾„ç»ˆç‚¹è¿›è¡Œæ±‚å’Œï¼ˆæ‰€ä»¥è¦è®°å¿†è·¯å¾„ï¼‰ï¼Œé‡‡ç”¨`vector`è¿›è¡Œæ¯”è¾ƒæ–¹ä¾¿å›æº¯

#### ä»£ç 

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int MAXV = 510;
const int INF = 1000000000;
int grid[MAXV][MAXV];
int cost[MAXV][MAXV];
int dis[MAXV];
bool vis[MAXV] = {false};
vector<int> pre[MAXV];
vector<int> tmpPath, path;
int min_cities = INF, min_cost = INF;
int cities, highways, st, ed;

int get_min_index()
{
    int min_value = INF, min_index = -1;
    for(int i=0;i<cities;i++)
    {
        if(!vis[i] && dis[i] < min_value)
        {
            min_value = dis[i];
            min_index = i;
        }
    }
    return min_index;
}//è¿”å›dis[]ä¸­æœ€å°çš„ç´¢å¼•

void Dijkstra()
{
    fill(dis, dis + MAXV, INF);
    dis[st] = 0;
    for(int cnt=0;cnt<cities;cnt++)
    {
        int u = get_min_index();
        if(u == -1)     return;
        vis[u] = true;
        for(int v=0;v<cities;v++)
        {
            if(!vis[v] && grid[u][v] != INF)
            {
                if(dis[u] + grid[u][v] < dis[v])
                {
                    dis[v] = dis[u] + grid[u][v];
                    pre[v].clear();		//pre[v]={}è¡¨ç¤ºç»“ç‚¹vçš„æœ€çŸ­è·¯å¾„çš„æ‰€æœ‰å¯èƒ½å‰é©±
                    pre[v].emplace_back(u);
                }else if(dis[u] + grid[u][v] == dis[v]){
                    pre[v].emplace_back(u);
                }
            }
        }
    }
}
void dfs(int cur)
{
    if(cur == st)   //å·²ç»æ‰¾åˆ°å…¶ä¸­ä¸€æ¡disæœ€å°çš„è·¯å¾„
    {
        tmpPath.emplace_back(cur);
        int sum = 0;
        for(int i=1;i<tmpPath.size();i++)
        {
            sum += cost[tmpPath[i-1]][tmpPath[i]];
        }
        if(sum < min_cost)	//è¿›è¡Œé€‰ä¼˜
        {
            min_cost = sum;
            min_cities = tmpPath.size();
            path = tmpPath;		//æ‰¾åˆ°ç¬¦åˆçš„è·¯å¾„è¦å­˜å‚¨ï¼Œä¹‹åæ˜¯è¦è¾“å‡ºçš„
        }
        tmpPath.pop_back();
    }
    tmpPath.emplace_back(cur);
    for(int i=0;i<pre[cur].size();i++)
        dfs(pre[cur][i]);
    tmpPath.pop_back();
}


int main() {
    
    cin >> cities >> highways >> st >> ed;
    
    fill(grid[0], grid[0] + MAXV*MAXV, INF);
    int u, v;
    for(int i=0;i<highways;i++)
    {
        cin >> u >> v;
        cin >> grid[u][v];
        grid[v][u] = grid[u][v];
        cin >> cost[u][v];
        cost[v][u] = cost[u][v];
    }
    Dijkstra();
    dfs(ed);
    for(int i=path.size()-1;i>=0;i--)
    {
        cout << path[i] << " ";
    }
    cout << dis[ed] << " " << min_cost << endl;
    return 0;
}
```

#### ğŸ”—

https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392

